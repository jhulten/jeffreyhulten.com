---
layout: tag
tag: antipatterns
title: Posts in antipatterns
---
        <li><a href="/2008/02/19/databases-as-a-beautiful-hammer.html">Databases as a Beautiful Hammer</a>
           &raquo; <abbr>19 Feb 2008</abbr>
        <li><a href="/2009/09/22/nfjs-fall-2009-day-one.html">NFJS - Fall 2009 - Day One</a>
           &raquo; <abbr>22 Sep 2009</abbr>
    <item> 
  		<title>Databases as a Beautiful Hammer</title> 
  		<link>http://tragicallyleet.com/2008/02/19/databases-as-a-beautiful-hammer.html</link> 
  		<comments>http://tragicallyleet.com/2008/02/19/databases-as-a-beautiful-hammer.html#comments</comments> 
  		<pubDate>Tue, 19 Feb 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/02/19/databases-as-a-beautiful-hammer.html</description> 
  		<content:encoded><![CDATA[ From [Good Math, Bad Math](http://scienceblogs.com/goodmath/2008/01/databases_are_hammers_mapreduc.php), an article about [recent criticism](http://www.databasecolumn.com/2008/01/mapreduce-a-major-step-back.html) of the [MapReduce](http://en.wikipedia.org/wiki/MapReduce) library.

To explain MapReduce:

> Suppose you're at work, and you need to do something that's 
> going to take a long time to run on your computer. You don't 
> want to wait. But you don't want to go out and spend a couple 
> of million dollars buying a supercomputer. How do you make it 
> run faster? One way is buy a whole bunch of cheap machines, 
> and make it run on all of them at once. Another is to notice 
> that your office has lots of computers - pretty much every 
> office has a computer on the desk of every employee. And at 
> any given moment, most of those computers aren't doing much. 
> So why not take advantage of that? When your machine isn't 
> doing much, you let you coworkers borrow the capability you're 
> not using; when you need to do something, you can borrow their 
> machines. So when you need to run something big, you can 
> easily find a pool of a dozen machines.

> MapReduce is a library that lets you adopt a particular, 
> stylized way of programming that's easy to split among a 
> bunch of machines. The basic idea is that you divide the 
> job into two parts: a Map, and a Reduce. Map basically 
> takes the problem, splits it into sub-parts, and sends 
> the sub-parts to different machines - so all the pieces 
> run at the same time. Reduce takes the results from the 
> sub-parts and combines them back together to get a single 
> answer.

The problem? Well it appears that Relational Database people think that MapReduce is a crock.  The author does a great job explaining their viewpoint and what they miss:

> When I first wanted to spend some time learning about 
> relational databases, my then boss told me a story about 
> database people, which I've found to be remarkably true. 
> The story is, RDB people have found the most beautiful, 
> wonderful, perfect hammer in the whole world. It's perfectly 
> balanced - not too heavy, not too light, and swings just 
> right to pound in a nail just right every time. The grip is 
> custom-made, fitted to the shape of the owners hand, so that 
> they can use it all day without getting any blisters. It's 
> also beautifully decorated - encrusted with gemstones and 
> gold filigree - but only in places that won't detract from 
> how well it works as a hammer. It really is the greatest 
> hammer ever. Relational database guys love their hammer. 
> It's just such a wonderful tool! And when they make something 
> with it, it really comes out great. In fact, they like it 
> so much that they think it's the only tool they need. If you 
> give them a screw, they'll just pound it in like it's a nail. 
> And when you point out to them that dammit, it's a screw, 
> not a nail, they'll say "I know that. But you can't expect 
> me to use a crappy little screwdriver when I have a magnificent 
> hammer like this!"
> 
> That's exactly what's going on here. They've got their relational 
> databases. RDBs are absolutely brilliant things. They're amazing 
> tools, which can be used to build amazing software. I've done a 
> lot of work using RDBs, and without them, I wouldn't have been 
> able to do some of the work that I'm proudest of. I don't want 
> to cut down RDBs at all: they're truly great. But not everything 
> is a relational database, and not everything is naturally suited 
> towards being treated as if it were relational. The criticisms of 
> MapReduce all come down to: "But it's not the way relational 
> databases would do it!" - without every realizing that that's the 
> point. RDBs don't parallelize very well: how many RDBs do you know 
> that can efficiently split a task among 1,000 cheap computers? 
> RDBs don't handle non-tabular data well: RDBs are notorious for 
> doing a poor job on recursive data structures. MapReduce isn't 
> intended to replace relational databases: it's intended to provide 
> a lightweight way of programming things so that they can run fast
> by running in parallel on a lot of machines. That's all it was 
> intended to do.

[Check it out](http://scienceblogs.com/goodmath/2008/01/databases_are_hammers_mapreduc.php) for full details.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS - Fall 2009 - Day One</title> 
  		<link>http://tragicallyleet.com/2009/09/22/nfjs-fall-2009-day-one.html</link> 
  		<comments>http://tragicallyleet.com/2009/09/22/nfjs-fall-2009-day-one.html#comments</comments> 
  		<pubDate>Tue, 22 Sep 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/09/22/nfjs-fall-2009-day-one.html</description> 
  		<content:encoded><![CDATA[ Its that time again! The No Fluff Just Stuff : Pacific Northwest Software Symposium has returned to the Redmond Marriot.

### Effective Java - Venkat Subramaniam

Unlike many talks, Venkat let us chose the topics. He put up a Jeopardy style board with categories like 'Syntax Sugar', 'Collections' and 'Objects' and let us pick. The content varied wildly, not in its quality (Venkat knows his stuff) but in just how deep into the rabbit hole it would lead you.

As an example, which is better?

{% highlight java %}
string1 + string2
new StringBuffer(string1).append(string2)
{% endhighlight %}

Normally you might think that the simple + would be less efficient, but thanks to syntactic sugar the opposite is true.

In Java 1.4 and above the simple + will use StringBuilder in the background. StringBuilder will preallocate space based on expectations and will not acquire and release locks like StringBuffer will.

There were a lot of code examples and we covered pitfalls and Java strangeness like the above.

### Common Antipatterns - Mark Richards

We started talking about common antipatterns in life as an example.

There are some common causes of anti-patterns:

- haste - aggressive deadlines and budgets drive lower standards of quality
- apathy - general lack of concern about finding the proper solution to a problem
- arrogance - refusal to accept solutions or practices generally known to be effective
- ignorance - failure (intentional or non-intentional) to seek a clear understanding of the problem space
- pride - refusal to leverage existing designs, code and frameworks; builds everything from scratch

**Object Orgy** - insufficiently encapsulated objects result in unrestricted access to their internals.

**Cargo Cult Programming** - using patters, methods and techniques without understanding why.

**Golden Hammer** - using the same tool, product or technique to solve every problem.

With the plethora of languages available on the JVM, we have all kinds of choice. For a comprehensive list of language options, see [http://www.is-research.de/info/vmlanguages/](http://www.is-research.de/info/vmlanguages/)

**Accidental Complexity** - introducing non-essential complexity into a solution.

> essential complexity: we have a hard problem
> 
> accidental complexity: we have made a problem hard
> 
> "developers are drawn to complexity like moths to a flame - often with the same result" - Neal Ford

**Lava Flow** - obsolete technologies and forgotten extensions leave hardened globules of dead code in its wake.

**The Blob** - an all encompassing class or component that knows too much and does too much.

Use a roles and responsibility model. Figure out in just a couple of sentences what the job of a given object is.

**Architecture by Implication** - systems lacking a clear architecture definition.

Don't rely too heavily on past experience; every problem is a little different.

### Groovy Testing - Scott Davis

There are some real benefits to using Groovy for testing. Groovy has the ability to get into the private guts of a Java object.

The concept of a 'private' field is a Java *language* construct, not a Java *platform* construct. This means you can get to private methods and fields.

### Keynote - Venkat Subramaniam

Venkat gave the keynote after dinner; an entertaining talk about the pointy-hairness in all of us, not just bosses.

 ]]></content:encoded> 
  		</item>
