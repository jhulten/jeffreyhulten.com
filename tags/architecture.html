---
layout: tag
tag: architecture
title: Posts in architecture
---
        <li><a href="/2009/04/14/nfjs-spring-2009-day-one.html">NFJS Spring 2009 - Day One</a>
           &raquo; <abbr>14 Apr 2009</abbr>
        <li><a href="/2009/04/16/nfjs-spring-2009-day-three.html">NFJS Spring 2009 - Day Three</a>
           &raquo; <abbr>16 Apr 2009</abbr>
    <item> 
  		<title>NFJS Spring 2009 - Day One</title> 
  		<link>http://tragicallyleet.com/2009/04/14/nfjs-spring-2009-day-one.html</link> 
  		<comments>http://tragicallyleet.com/2009/04/14/nfjs-spring-2009-day-one.html#comments</comments> 
  		<pubDate>Tue, 14 Apr 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/04/14/nfjs-spring-2009-day-one.html</description> 
  		<content:encoded><![CDATA[ *NOTE: I am posting these entries a week and a half after the Spring 2009 event in Seattle due to time constraints in editing and such.*

It's my first time as an Alumni at a [No Fluff Just Stuff](http://nofluffjuststuff.com) conference. Attendance is smaller than the Fall '08 show, but I understand that is pretty typical. I am glad to see that this conference is surviving in the lean times.

After the introduction I attended [Neal Ford's](http://nealford.com) presentation on [Emergent Design and Evolutionary Architecture](http://nealford.com/downloads/conferences/canonical/Neal_Ford-Emergent_Design_and_Evolutionary_Architecture-slides.pdf). Neal's presentation is based around a series of articles he is working on for the [IBM DeveloperWorks](http://www.ibm.com/developerworks/java/library/j-eaed1/) web site. One of the key points he made was that emerging design is really about identifying patterns (not to be confused with Patterns, such as from the GOF book, [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/gp/product/0201633612?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201633612)).

> "Software is more about communication than technology" -- Neal Ford

Expressiveness matters! You will probably not see patterns and potential abstractions in Assembler code. The more expressive the language (Python, Ruby and Groovy being great examples) the more likely you are to see the places where you can refactor.

A word of warning! Do not try abstracting too early in the development process. Abstractions should come from working source code, not from your preconceived ideas of what abstractions are needed.

Neal then covered one of my favorite topics, technical debt. Every project has external forces that cause compromise. The key is to convince someone in power (management) that technical debt exists and then start a conversation about repayment.

Demonstration trumps discussion in this case. Use metrics from your project like cyclomatic complexity per line of code. As a process and operations guy I am a huge fan of proper metrics. The more technical debt you have the harder it is to see the emergent design of the project.

In the end, software and application design is about code; all other artifacts are transient and should be tossed when it diverges from the code. Out-of-date documentation is worse than none because it is actively misleading. Depending on the project you may find that keeping your documentation up to date is important, but you need to take the cost into account.

Some references include Neal's [The Productive Programmer](http://www.amazon.com/gp/product/0596519788?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0596519788) and [The Productive Programmer](http://www.amazon.com/gp/product/0596519788?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0596519788).

<!-- NOTE - XRAY FOR ECLIPSE -->After a short break we reassembled for another Neal Ford presentation, '[Real World Refactoring](http://nealford.com/downloads/conferences/canonical/Neal_Ford-Real_World_Refactoring-slides.pdf)'. Since all the major tools provide refactoring facilities Neal focused on when and why to refactor.

First he talked about the building blocks of refactoring. ‘Composed method’ was the first, specifically divide your code into many small methods that each complete one and only one task. If you have a method longer than ten lines you have a candidate for method composition.

Once you have broken your methods up you can see if there are common pieces you can refactor up to a parent class. The key is that in the end a class can be only about one thing, shorter methods are easier to test, and you can find reusable assets where you didn't know they were there.

The second building block was SLAP or the Single Layer of Abstraction Principle. The key of this idea is that crossing layers of abstraction, like from business logic to database logic, within one method is difficult to visualize and probably a good candidate for refactoring.

> "Refactoring is a disciplined technique for restructuring 
> an existing body of code, altering its internal structure 
> without changing its external behavior." -- Martin Fowler

Moving on he talked about decomposition, specifically taking large classes and breaking them down and decoupling from vendor libraries. It was a little complicated to try and explain which probably means I still don't understand it entirely. He did state that you should not decompose large things just because you can, they may not be evil. For example, the object representing your most important and strategic concept will probably be large and you may break the conversation with your business owners.

So you want to refactor, one of the questions people ask is if you should branch when you refactor. The real problem is the merge hell you go through at the end. To mitigate that risk, time box your efforts and don't be afraid to toss your efforts. You miscalculated the effort required and the breakage from weeks of merge hell and broken code are not worth it. Take a step back and rescope your efforts to something smaller.

One of a important refactoring issues for me is refactoring the database schema. For this there is a project called dbDeploy to help you manage the changes to your schema. One of the keys for refactoring is using triggers to synchronize data (such as in the case of moving a column) for the duration of the change window.

[![Thoughtworks Anthology](https://images-na.ssl-images-amazon.com/images/I/51%2BDJ2%2BWuAL._SL160_.jpg){: .right}](http://www.amazon.com/gp/product/193435614X?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=193435614X)

Pragmatic Programmers came out with a book called 'A ThoughtWorks Anthology' which has an essay called 'Refactoring Ant Build Files'. It shows how you can apply common refactoring principals to Ant build files to remove the cruft that builds up over time.

After another break I moved over to another room to attend Scott Davis' presentation on DSLs (Domain Specific Languages) in Groovy. An example of a domain is Facebook, which we would consider a part of the social networking domain. Amazon is part of the Internet sales and cloud computing domains.

One of the dangers is attempting to put too much domain and losing the specific nature of the DSL. The joy of DSLs is the ability to build the language tools specific for the job. SQL is an example of a domain specific language as is ANT. SQL provides a strong language for retrieving data. ANT is intended just for building Java code.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS Spring 2009 - Day Three</title> 
  		<link>http://tragicallyleet.com/2009/04/16/nfjs-spring-2009-day-three.html</link> 
  		<comments>http://tragicallyleet.com/2009/04/16/nfjs-spring-2009-day-three.html#comments</comments> 
  		<pubDate>Thu, 16 Apr 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/04/16/nfjs-spring-2009-day-three.html</description> 
  		<content:encoded><![CDATA[ NOTE: I delayed posting these entries to clean up my notes and add some useful links.

<i>GRUMPY NOTE: I lost a bunch of notes so this is based on my faulty memory and some slides.</i>

I got in a little late today after grabbing coffee and headed to [Michael Nygard's](http://michaelnygard.com/) presentation "Architect for Scale". I love the smell of capacity math in the morning.

### Amdahl's Law

$$ T_p = \sigma T_1 + ( 1 - \sigma ) \frac{T_1}{p} $$ 

#### Speedup Ratio

[pmath]S_p=T_1/1+sigma(p-1) [/pmath] 

### Universal Scalability Law

[pmath]C_p=p/1+sigma(p-1)+kappa p(p-1)[/pmath]
where
[pmath]sigma[/pmath] = contention
[pmath]kappa[/pmath] = coherency

Michael mentioned a book, [Guerrilla Capacity Planning](http://www.amazon.com/gp/product/3540261389?ie=UTF8&tag=mylibrary01-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=3540261389) by Neil Gunther. It covers a lot of the mathematics of scalability and capacity planning.

There are only two ways to increase scalability: decrease contention or decrease conherency. Why is "improve performance" not on the list? Increasing performance increases capacity. Scalability is the measure of how added resources impact added capacity. Increasing performance can reduce your need for scalability, but does not benefit scalability. An interesting side note was that increasing performance generally means making the serial portion ([pmath]sigma[/pmath]) a larger portion of the total time. This means that as you spend more time on performance, you actually create a situation where you will reach maximum capacity with fewer processing resources.

### Brewer's Conjecture

You have heard the old quote "Faster, better, cheaper... Pick two"? Well when you are talking about systems architecture you can choose at most two of the following: 

- Consistency
- Availability
- Partition-Tolerance

Lets look at Michael's definitions: 

Consistency:
  There exists a total ordering on all operations, and all nodes in the system agree on that ordering at every point in time.
Availability:
  Every request received by a non-failing node must result in a response
Partition-Tolerance:
  The network may lose arbitrarily many messages from any subset of nodes to any other subset of nodes.

You want your system to be consistent and available? Partitioning is not allowed. How are you going to prevent partitioning? Do you expect servers, switches and network cards to never fail? This is unrealistic.

You want your system to be consistent and partitionable? Consistency can only be guaranteed if the service is unavailable during partitions. Otherwise you end up with 'split-brain'.

You want your system to be available and partitionable? We maintain availability during partitions by allowing different subsets to report different histories. This means that agreement or synchronization protocols are forbidden.

An important note: when you use and rely on ACID compliance of a relational database, you inherently select **Consistency**.

> "If you can't split it, you can't scale it." -- Randy Shoup, eBay

All partitioning strategies assume no cross-cluster dependencies on shared data. Shared writable data requires serialized access which raised [pmath]sigma[/pmath].

The database theory example for ACID compliance of a bank transaction is flawed as soon as User A and User B are with different banks. Instead of 'always consistent' we need to think about 'eventually consistent'.

[![Release It!](https://images-na.ssl-images-amazon.com/images/I/41Nb-knuW-L._SL160_.jpg){: .left}](http://www.amazon.com/gp/product/0978739213?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0978739213)

I decided to hang around for Michael's next talk, 'The 90-Minute Startup'. He talked about Amazon EC2. I lost all my notes on this talk, but seeing the cloud in action was pretty cool.

After lunch we had the expert panel discussion where Ken Sipe, Ted Neward, Matthew McCullough, Brian Sam-Bodden, and Michael Nygard talked about issues like the potential future of software development regulation, the potential impact of the IBM-Sun aquisition, and parallels between software engineering and the medical, legal, and construction.

After the panel I attended Ken Sipe's session on Java Memory, Performance, and Garbage Collection. I learned a bunch about the theory of garbage collection on the JVM. I picked up a few nice tips. To speed up your JVM startup time set your PermSpace and MaxPermSpace to the values based on what you see while your application is running. This way the JVM is not allocating space, finding is insufficent, reallocating over and over as you start up.

Some useful equations from the JVM memory management talk.

[pmath]E=S_n-(S_n/(R_s+2))*2[/pmath]

[pmath]S_s=(S_n-E)/2[/pmath]

where
[pmath]E[/pmath] = Size of Eden
[pmath]S_n[/pmath] = Size of New Space
[pmath]R_s[/pmath] = Survivor Ratio
[pmath]S_s[/pmath] = Size of Survivor Space

jps allows you to see processes either locally or remotely.

jstatd exposes the process information to jps over the network. A java security policy file is needed.

I stuck around for Ken&rsquo;s session as my last of the day, &ldquo;Debugging the Production JVM&rdquo;. After an example of VisualVM he moved into BTrace, a new feature in Java 1.6. It allows you to instrument a running JVM and get events when methods are called, or other activities take place.

All in all I had a great time and learned a whole bunch.
 ]]></content:encoded> 
  		</item>
