---
layout: tag
tag: metaprogramming
title: Posts in metaprogramming
---
        <li><a href="/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html">No Fluff Just Stuff: Fall 2008 - Day 2 - Part 1</a>
           &raquo; <abbr>20 Sep 2008</abbr>
        <li><a href="/2009/09/23/nfjs-day-two.html">NFJS - Fall 2009 - Day Two</a>
           &raquo; <abbr>23 Sep 2009</abbr>
    <item> 
  		<title>No Fluff Just Stuff: Fall 2008 - Day 2 - Part 1</title> 
  		<link>http://tragicallyleet.com/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html</link> 
  		<comments>http://tragicallyleet.com/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html#comments</comments> 
  		<pubDate>Sat, 20 Sep 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html</description> 
  		<content:encoded><![CDATA[ I got in today at 0830 for some breakfast, talked with some coworkers and tablemates, then moved out to the first session.

My first session was once again with Jeff Brown of [G2One](http://g2one.com). He talked about Test Driven Development with Groovy and Grails. TDD is one of those things that I know I should do but don't discipline myself to do. Groovy does some nice things that I like from Ruby. Duck-typing is great when you are working with tests. You aren't writing a bunch of interfaces just to make the compiler happy.

Another interesting test piece is the Expando class in GroovyTest. Expand allows you to create a class that pretends to be anything you need such as a file. Therefore you can test object that, for instance, write to the filesystem without actually writing to the filesystem in your unit test.

Interesting clarification was the differences between mocks and stubs. Mocks have strong expectations and stubs have loose expectations. The stubs in GroovyTest are slick. You call new StubFor(class) and get a stub back that you can overload the functionality of, allowing you to change the functionality of a Groovy or Java class for the purpose of your test.

For my second session I had some hard choices to make. I selected [Mark Richards](http://wmrichards.com/) talk on Java Persistence over the Powerful Metaprogramming Techniques with Groovy with Jeff Brown, but it was a tough choice. Mark is a Director and Senior Architect at Collaborative Consulting LLC and the Author of Java Transactional Design Strategies.

Mark was a dynamic speaker and really engaged people. His focus was that there will never be a silver bullet for persistence. Each toolset has it's strong points and weak points. He started talking about the types of Java persistence frameworks, specifically Object-Relational Mapper, SQL Mapper and Standards Based Frameworks.

One of the big differences between an ORM and a SQL Mapper is that where ORM maps objects to tables, a SQL Mapper maps objects to result sets. This has hefty implications if you need to change from MySQL to Oracle. In a ORM the SQL is generated by the API so you don't need to do anything but change the dialect used by the ORM.

iBatis is a SQL Mapper that keeps the mapping of statements, result sets and such in XML. Since the SQL is not generated automatically you have the chance to tune your queries.

He tangented off to a couple of things. One was the Triangle of Knowledge. The first area is what you know, the second area is that which you don't know, and lastly is the things that you don't know that you don't know. This is important in learning anything new, you can focus on the things that you NEED to know, as opposed to know that you don't know and therefore can look up. I like to think of this as Just In Time knowledge.

The big finale was talking about the impedance mismatch between reporting queries and ORMs. An ORM is great when you need CRUD operations, but the moment you need to run a complex reporting type query there is no longer a table to map to and no key to get the data from the cache. iBatis makes things easier in that case, but CRUD is a pain. The end result is to combine ORM and SQL mapping frameworks. One limitation, however is that you cannot combine iBatis and Hibernate in the same transactional unit of work. Therefore it works when you have a project with separate CRUD and reporting areas of function.

My brain is a bit full, so I am glad that lunch is next!

BTW: Acronym of the day: RDD -- Resume Driven Development. i.e. when someone makes choices based on what technology they want on their resume instead of the requirements of the project.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS - Fall 2009 - Day Two</title> 
  		<link>http://tragicallyleet.com/2009/09/23/nfjs-day-two.html</link> 
  		<comments>http://tragicallyleet.com/2009/09/23/nfjs-day-two.html#comments</comments> 
  		<pubDate>Wed, 23 Sep 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/09/23/nfjs-day-two.html</description> 
  		<content:encoded><![CDATA[ ### Dim Sum Grails - Scott Davis

Grails is an open-source web framework written in Groovy. Grails is being used by major players like Wired.com, Taco Bell in Canada, and more. 

If you have ever created a domain (model) object in Grails and noticed the scaffolding lists fields in alphabetical order, there is a simple way past this. When you add your fields to the static constraints closure, Grails will output them in the order provided.

{% highlight groovy %}
class MyObject {
	String firstName
	String lastName
	Integer age
	
	static constraints = {
		lastName()
		firstName()
		age()
	}
}
{% endhighlight %}

Want to add Lucene to your application? Try this.

{% highlight text %}
> grails install-plugin searchable
{% endhighlight %}

All that is left to give yourself a search engine is add searchable=true to your domain classes.

{% highlight groovy %}
class MyObject {
	...
	static searchable = true	
	...
}
{% endhighlight %}

Once you have done that, start your application with grails run-app annd go to http://localhost:8080/app/searchable to see your search page.

### Design Patterns in Java and Groovy - Venkat Subramaniam

I have always had an interest in patterns since I attended Pattern Languages of Programming (PLoP) in 2006. Venkat refered to Java as a post-pattern language; the Gang of Four Design Patterns book came out just before Java, and so patterns are far easier to implement in Java than C++. Likewise we have power and flexibility in Groovy that we do not have in Java that enables pattern implementation.

I found myself in an interesting conversation with Barbee Davis and Ted Neward, so I was late to the next session.

### MOPping up Groovy - Venkat Subramaniam

This session was about meta-programming techniques in Groovy. My favorite part was the end where Venkat wrote a  executable DSL (domain specific language) in Groovy.

At this point I was pretty tired and none of the last set of panels really interested me, so I went home a little early.
 ]]></content:encoded> 
  		</item>
