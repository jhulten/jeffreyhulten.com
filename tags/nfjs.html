---
layout: tag
tag: nfjs
title: Posts in nfjs
---
        <li><a href="/2008/09/19/no-fluff-just-stuff-fall-2008-day-1.html">No Fluff Just Stuff: Fall 2008 - Day 1</a>
           &raquo; <abbr>19 Sep 2008</abbr>
        <li><a href="/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html">No Fluff Just Stuff: Fall 2008 - Day 2 - Part 1</a>
           &raquo; <abbr>20 Sep 2008</abbr>
        <li><a href="/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-2.html">No Fluff Just Stuff: Fall 2008 - Day 2 - Part 2</a>
           &raquo; <abbr>20 Sep 2008</abbr>
        <li><a href="/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-1.html">No Fluff Just Stuff: Fall 2008 - Day 3 - Part 1</a>
           &raquo; <abbr>21 Sep 2008</abbr>
        <li><a href="/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-2.html">No Fluff Just Stuff: Fall 2008 - Day 3 - Part 2</a>
           &raquo; <abbr>21 Sep 2008</abbr>
        <li><a href="/2009/04/14/nfjs-spring-2009-day-one.html">NFJS Spring 2009 - Day One</a>
           &raquo; <abbr>14 Apr 2009</abbr>
        <li><a href="/2009/04/16/nfjs-spring-2009-day-three.html">NFJS Spring 2009 - Day Three</a>
           &raquo; <abbr>16 Apr 2009</abbr>
        <li><a href="/2009/09/22/nfjs-fall-2009-day-one.html">NFJS - Fall 2009 - Day One</a>
           &raquo; <abbr>22 Sep 2009</abbr>
        <li><a href="/2009/09/23/nfjs-day-two.html">NFJS - Fall 2009 - Day Two</a>
           &raquo; <abbr>23 Sep 2009</abbr>
        <li><a href="/2009/09/24/nfjs-fall-2009-day-three.html">NFJS – Fall 2009 – Day Three</a>
           &raquo; <abbr>24 Sep 2009</abbr>
    <item> 
  		<title>No Fluff Just Stuff: Fall 2008 - Day 1</title> 
  		<link>http://tragicallyleet.com/2008/09/19/no-fluff-just-stuff-fall-2008-day-1.html</link> 
  		<comments>http://tragicallyleet.com/2008/09/19/no-fluff-just-stuff-fall-2008-day-1.html#comments</comments> 
  		<pubDate>Fri, 19 Sep 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/09/19/no-fluff-just-stuff-fall-2008-day-1.html</description> 
  		<content:encoded><![CDATA[ It has been an interesting day. I talked my boss into letting me use my annual 'tuition' reimbursement to attend the Pacific Northwest Software Symposium put on my [No Fluff Just Stuff](http://nofluffjuststuff.com) in Redmond. The conference is different in that they cover hard core topics with no marketing spin. They do not have an expo hall, just breakout room with speakers that know their stuff.

I arrived at the Redmond Town Center Marriott at noon and checked in. Some of my coworkers, developers for whom this was training, were already there and we talked for a bit. The event started at 1300 with a short introduction session and then it was off to my first breakout session.

I spent the majority of the day in one room listening to one guy speak. [Jeff Brown](http://javajeff.blogspot.com/) is the VP of Professional Services at [G2One](http://g2one.com/) and a member of the core Groovy and Grails development teams. The first session was an introduction to [Groovy](http://groovy.codehaus.org/), a dynamic language that runs inside the Java Virtual Machine. I learned a few interesting things, but Groovy is similar in a lot of ways to Ruby so it wasn't too much of a stretch.

The second session with Jeff was about Grails. [Grails ](http://grails.org/)is a Java web framework built on top of Groovy. While the end result is a WAR file, you do not have all the nasty configuration files to wire together all the parts of your application. Grails includes Hibernate, Spring, log4j and other technologies but takes the heavy lifting away allowing the programmer to get to the core of the data domain and business logic.

Third was a session on advanced Grails where Jeff covered relationships, templates (what Rails calls 'partials'), custom tag libraries (worth the price of admission right there!), AJAX and more. This session was largely a live coding exercise and we walked through most anything that someone could come up with. While this was going on I created a basic Grails app myself and mucked around a bit.

Jeff was a really good speaker and was focused on getting the most content across that he could. I enjoyed his sessions and learned a far bit.

Then came dinner with great cheese bread and a terrific chocolate cake. I ate more of that than I should have.

After dinner we heard a keynote from one of the presenters, Jared Richardson. Jared, the co-author of a great book called [Ship It! A Practical Guide to Successful Software Projects](http://www.amazon.com/Practical-Guide-Successful-Software-Projects/dp/0974514047?SubscriptionId=1N9AHEAQ2F6SVD97BE02&tag=tragicallyl33-20&linkCode=xm2&camp=2025&creative=165953&creativeASIN=0974514047), spoke about what he called &quot;Career 2.0&quot;. The focus of this keynote was that you need to treat your knowledge as you would any other investment. No one else is going to invest in you like you will. Diversify your investments so that you are more insulated from the whims of the job market. Acknowledge it will take effort, set goals and plan accordingly.

Also he talked at length about sharing the things that you know. He pushed hard on blogging; blog about every problem you solve, every mistake you make and correct, every thing you research. If you write lots you get better at writing and you make a name for yourself. I liked the concept of getting beyond resumes to name recognition.

Anyway, I really enjoyed today and am looking forward to tomorrow. More to come...
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>No Fluff Just Stuff: Fall 2008 - Day 2 - Part 1</title> 
  		<link>http://tragicallyleet.com/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html</link> 
  		<comments>http://tragicallyleet.com/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html#comments</comments> 
  		<pubDate>Sat, 20 Sep 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-1.html</description> 
  		<content:encoded><![CDATA[ I got in today at 0830 for some breakfast, talked with some coworkers and tablemates, then moved out to the first session.

My first session was once again with Jeff Brown of [G2One](http://g2one.com). He talked about Test Driven Development with Groovy and Grails. TDD is one of those things that I know I should do but don't discipline myself to do. Groovy does some nice things that I like from Ruby. Duck-typing is great when you are working with tests. You aren't writing a bunch of interfaces just to make the compiler happy.

Another interesting test piece is the Expando class in GroovyTest. Expand allows you to create a class that pretends to be anything you need such as a file. Therefore you can test object that, for instance, write to the filesystem without actually writing to the filesystem in your unit test.

Interesting clarification was the differences between mocks and stubs. Mocks have strong expectations and stubs have loose expectations. The stubs in GroovyTest are slick. You call new StubFor(class) and get a stub back that you can overload the functionality of, allowing you to change the functionality of a Groovy or Java class for the purpose of your test.

For my second session I had some hard choices to make. I selected [Mark Richards](http://wmrichards.com/) talk on Java Persistence over the Powerful Metaprogramming Techniques with Groovy with Jeff Brown, but it was a tough choice. Mark is a Director and Senior Architect at Collaborative Consulting LLC and the Author of Java Transactional Design Strategies.

Mark was a dynamic speaker and really engaged people. His focus was that there will never be a silver bullet for persistence. Each toolset has it's strong points and weak points. He started talking about the types of Java persistence frameworks, specifically Object-Relational Mapper, SQL Mapper and Standards Based Frameworks.

One of the big differences between an ORM and a SQL Mapper is that where ORM maps objects to tables, a SQL Mapper maps objects to result sets. This has hefty implications if you need to change from MySQL to Oracle. In a ORM the SQL is generated by the API so you don't need to do anything but change the dialect used by the ORM.

iBatis is a SQL Mapper that keeps the mapping of statements, result sets and such in XML. Since the SQL is not generated automatically you have the chance to tune your queries.

He tangented off to a couple of things. One was the Triangle of Knowledge. The first area is what you know, the second area is that which you don't know, and lastly is the things that you don't know that you don't know. This is important in learning anything new, you can focus on the things that you NEED to know, as opposed to know that you don't know and therefore can look up. I like to think of this as Just In Time knowledge.

The big finale was talking about the impedance mismatch between reporting queries and ORMs. An ORM is great when you need CRUD operations, but the moment you need to run a complex reporting type query there is no longer a table to map to and no key to get the data from the cache. iBatis makes things easier in that case, but CRUD is a pain. The end result is to combine ORM and SQL mapping frameworks. One limitation, however is that you cannot combine iBatis and Hibernate in the same transactional unit of work. Therefore it works when you have a project with separate CRUD and reporting areas of function.

My brain is a bit full, so I am glad that lunch is next!

BTW: Acronym of the day: RDD -- Resume Driven Development. i.e. when someone makes choices based on what technology they want on their resume instead of the requirements of the project.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>No Fluff Just Stuff: Fall 2008 - Day 2 - Part 2</title> 
  		<link>http://tragicallyleet.com/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-2.html</link> 
  		<comments>http://tragicallyleet.com/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-2.html#comments</comments> 
  		<pubDate>Sat, 20 Sep 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/09/20/no-fluff-just-stuff-fall-2008-day-2-part-2.html</description> 
  		<content:encoded><![CDATA[ After lunch I bought a few books and then headed to the 'mystery panel' (a typo on the schedule) about Code Metrics with Neal Ford. After a brief tour of tools we started to talk about the meaning of various metrics. First, KLOC or thousands of lines of code is meaningless or worse.

Cyclomatic complexity measures the complexity of a function. The basis of this is metric is pretty simple. Treating the code as a graph G where statements are nodes and paths are edges the metric is V(G) = e - n + 2 where e is the number of edges and n is the number of nodes.

FLOG is a tool for Ruby that assigns a value to each type of action, such as literals, branching, assignment, etc. Add the values of the actions and you get a sense of the complexity of the function. Neal said that you can run FLOG on the codebase of any Ruby project and the file with the highest score is almost guaranteed to be the one with the most bugs.

Next he covered the Chidamber and Kemerer object-oriented metrics. They covered two types; easy but not useful and very useful. The latter category includes the # of methods executed due to the method call, sum of other classes that this class uses, and the sum of how many classes use this class.

A side note, he was using a tool on the Mac called oXygen that provided a fairly sane way to work with XML documents.

jdepend was the next tool he covered, which reports based on packages instead of classes. It calculates the efferent and afferent couplings, just like the C&amp;K OO Metrics but extrapolates instability, abstractness, and distance from the main sequence. Distance from the main sequence states that packages should either be very abstract and highly stable, or highly unstable but very concrete.

All in all a lot of great content, especially on communicating the metrics as a part of developer motivation, etc.

My last official session of the day was titled &quot;The Busy Java Developer's Guide to Performance and Scalability&quot;. Ted Neward is a self-proclaimed language whore, with books on Java, XML, and .NET under his belt.

He had a simple definition of performance and scalability. Performance is how fast the application responds to an end user. Scalability is the number of users you can support.

His steps were pretty straightforward:

- Know your performance and scalability goals.
- Avoid the pitfalls of assumptions.
- Measure, measure, measure.
- Refactor or redesign as necessary.

The base assumptions to avoid are pretty obvious, but as developers we seem to ignore:

- Myth: bandwidth is infinite
- Myth: latency is zero
- Myth: transport cost is zero
- Myth: topology doesn't change
- Myth: the system is homogeneous
- Myth: you &quot;know&quot; where slowdowns and bottlenecks are

These are all great points to remember are NOT true. If you look at the difference between google.com and amazon.com home pages are a great example of myth one. Amazon seems to think that bandwidth is infinite, where Google understands that it is not!

One of the tools he demonstrated was jConsole, where you can view the memory, CPU and other metrics about your application.  This hits on myth six; do not assume you know where your issues are.  Measurement is the only meaningful way to evaluate your code.

Another great day, Birds of a Feather sessions next then I am off home. ]]></content:encoded> 
  		</item>
    <item> 
  		<title>No Fluff Just Stuff: Fall 2008 - Day 3 - Part 1</title> 
  		<link>http://tragicallyleet.com/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-1.html</link> 
  		<comments>http://tragicallyleet.com/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-1.html#comments</comments> 
  		<pubDate>Sun, 21 Sep 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-1.html</description> 
  		<content:encoded><![CDATA[ I got in a little late today, about 0845, which meant a fast breakfast and then off to the first session: Managing Project Integrity with David Bock of [CodeSherpas](http://codesherpas.com). This session was a whirlwind tour of tools to provide greater management and documentation of your code, from Maven to jDepend, Xradar to PMD. I didn't have power for my laptop and the battery was near dead so I don't have a lot of notes on the topic, but I do have a few ideas.

Next session was also with David Bock, Intermediate Maven. For those who do not know Maven it is a build management tools similar in some ways to Ant. I understand so much more than I did about Maven, especially the simple things like what the points in the lifecycle are and what order they run in. I am sure this is documented somewhere, but I just haven't found it.

We got into a great discussion about using private repositories to manage dependencies like Archiva or Artifactory. Between making sure that you always get the same version of, for instance, jUnit 3.8.1 and lowering your initial project setup time by caching those packages there doesn't seem to be much reason not to set one up. Just make sure you back it up!

Then we got into running Ant tasks inside of Maven, which is very cool. The ease of adding existing Ant targets to a lifecycle phase in Maven is slick. I will see about posting some examples of this later on.

Writing Maven plugins are pretty trivial. Maven gives you an archetype to build a base package and then it is just customization (maven-archetype-mojo). The process is pretty simple to build out, however it adds more complexity to your build process real fast.

Next is lunch followed by the expert panel discussion.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>No Fluff Just Stuff: Fall 2008 - Day 3 - Part 2</title> 
  		<link>http://tragicallyleet.com/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-2.html</link> 
  		<comments>http://tragicallyleet.com/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-2.html#comments</comments> 
  		<pubDate>Sun, 21 Sep 2008 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2008/09/21/no-fluff-just-stuff-fall-2008-day-3-part-2.html</description> 
  		<content:encoded><![CDATA[ After lunch we had the 'expert panel discussion' where the speakers. One of the great quotes was "If you use Eclipse just because it is free we have a name for that... arranged marriage. You can get some things done, but there is no love."

I then went to "The Busy Developers Guide to Annotations" with [Ted Neward](http://tedneward.com) who was on the expert group that defined the annotations facility. After a thought experiment that covered how you would mark a class as Serializable in the old Java 1.1 days we moved to a live code example implementing an annotation on a person object.

The annotation example we developed was a validation annotation. The annotation sits in front of the thing that it modifies, just like the public keyword. An annotation adds no code to the method or class it modifies, just data that is accessible via reflection. Anything that you can put annotations on has the AnnotationElement interface, including classes and methods, in the reflection API. I learned that annotations have annotations including @Retention, which specifies how long the annotation should be available, either RUNTIME, SOURCE, or CLASS, and @Target which specifies where the annotation can be used, either methods, fields, classes, constructors and more.

Annotations should never be used to carry configuration information such as filenames or defaults. They cannot be changed at runtime. Annotations are compiled to an interface by the compiler.

A great observation from Ted is that while it is not acceptable to add a keyword to a twelve year old language, it is acceptable to use a existing keyword in a new and confusing context.

For my last session of the weekend I embraced my inner masochist and attended Venkat Subramaniam's talk on Functional Programming on the Java Virtual Machine. Functional programming is focused on well-behaved functions. Some of the benefits of a functional programming model is working with multi-core machines. When your functions can be passed to functions and functions do not have side effects, you can split those functions across multiple processors without data integrity issues.

An interesting point from Venkat is to initially ignore the syntax of a language and focus on the idiom. Every programming language hurts when you first learn it, but the compiler will catch the syntax errors.

His first example was from erlang, which is a pure functional language but not on the JVM.

{% highlight erlang %}
main(_) -> io:format("~p", [double([1,2,3,4,5])).
double(L) -> lists:map(fun(E) -> E * 2 end, L).
{% endhighlight %}

This takes the array 1 to 5 and runs the double function, then passes it to io:format to print to the console. The double function runs lists:map to run every element of the array and executes the anonymous function to double the value of each element.

Scala is a functional programming language that runs in the JVM. You can write Java like code in Scala, but you lose the concurrence protection.

{% highlight scala %}
val lst = List(1,2,3,4,5)
println(lst.map(_ * 2))
{% endhighlight %}

This is the same functionally (no pun intended) as the erlang code above.

Its official, my brain hurts.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS Spring 2009 - Day One</title> 
  		<link>http://tragicallyleet.com/2009/04/14/nfjs-spring-2009-day-one.html</link> 
  		<comments>http://tragicallyleet.com/2009/04/14/nfjs-spring-2009-day-one.html#comments</comments> 
  		<pubDate>Tue, 14 Apr 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/04/14/nfjs-spring-2009-day-one.html</description> 
  		<content:encoded><![CDATA[ *NOTE: I am posting these entries a week and a half after the Spring 2009 event in Seattle due to time constraints in editing and such.*

It's my first time as an Alumni at a [No Fluff Just Stuff](http://nofluffjuststuff.com) conference. Attendance is smaller than the Fall '08 show, but I understand that is pretty typical. I am glad to see that this conference is surviving in the lean times.

After the introduction I attended [Neal Ford's](http://nealford.com) presentation on [Emergent Design and Evolutionary Architecture](http://nealford.com/downloads/conferences/canonical/Neal_Ford-Emergent_Design_and_Evolutionary_Architecture-slides.pdf). Neal's presentation is based around a series of articles he is working on for the [IBM DeveloperWorks](http://www.ibm.com/developerworks/java/library/j-eaed1/) web site. One of the key points he made was that emerging design is really about identifying patterns (not to be confused with Patterns, such as from the GOF book, [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/gp/product/0201633612?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0201633612)).

> "Software is more about communication than technology" -- Neal Ford

Expressiveness matters! You will probably not see patterns and potential abstractions in Assembler code. The more expressive the language (Python, Ruby and Groovy being great examples) the more likely you are to see the places where you can refactor.

A word of warning! Do not try abstracting too early in the development process. Abstractions should come from working source code, not from your preconceived ideas of what abstractions are needed.

Neal then covered one of my favorite topics, technical debt. Every project has external forces that cause compromise. The key is to convince someone in power (management) that technical debt exists and then start a conversation about repayment.

Demonstration trumps discussion in this case. Use metrics from your project like cyclomatic complexity per line of code. As a process and operations guy I am a huge fan of proper metrics. The more technical debt you have the harder it is to see the emergent design of the project.

In the end, software and application design is about code; all other artifacts are transient and should be tossed when it diverges from the code. Out-of-date documentation is worse than none because it is actively misleading. Depending on the project you may find that keeping your documentation up to date is important, but you need to take the cost into account.

Some references include Neal's [The Productive Programmer](http://www.amazon.com/gp/product/0596519788?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0596519788) and [The Productive Programmer](http://www.amazon.com/gp/product/0596519788?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0596519788).

<!-- NOTE - XRAY FOR ECLIPSE -->After a short break we reassembled for another Neal Ford presentation, '[Real World Refactoring](http://nealford.com/downloads/conferences/canonical/Neal_Ford-Real_World_Refactoring-slides.pdf)'. Since all the major tools provide refactoring facilities Neal focused on when and why to refactor.

First he talked about the building blocks of refactoring. ‘Composed method’ was the first, specifically divide your code into many small methods that each complete one and only one task. If you have a method longer than ten lines you have a candidate for method composition.

Once you have broken your methods up you can see if there are common pieces you can refactor up to a parent class. The key is that in the end a class can be only about one thing, shorter methods are easier to test, and you can find reusable assets where you didn't know they were there.

The second building block was SLAP or the Single Layer of Abstraction Principle. The key of this idea is that crossing layers of abstraction, like from business logic to database logic, within one method is difficult to visualize and probably a good candidate for refactoring.

> "Refactoring is a disciplined technique for restructuring 
> an existing body of code, altering its internal structure 
> without changing its external behavior." -- Martin Fowler

Moving on he talked about decomposition, specifically taking large classes and breaking them down and decoupling from vendor libraries. It was a little complicated to try and explain which probably means I still don't understand it entirely. He did state that you should not decompose large things just because you can, they may not be evil. For example, the object representing your most important and strategic concept will probably be large and you may break the conversation with your business owners.

So you want to refactor, one of the questions people ask is if you should branch when you refactor. The real problem is the merge hell you go through at the end. To mitigate that risk, time box your efforts and don't be afraid to toss your efforts. You miscalculated the effort required and the breakage from weeks of merge hell and broken code are not worth it. Take a step back and rescope your efforts to something smaller.

One of a important refactoring issues for me is refactoring the database schema. For this there is a project called dbDeploy to help you manage the changes to your schema. One of the keys for refactoring is using triggers to synchronize data (such as in the case of moving a column) for the duration of the change window.

[![Thoughtworks Anthology](https://images-na.ssl-images-amazon.com/images/I/51%2BDJ2%2BWuAL._SL160_.jpg){: .right}](http://www.amazon.com/gp/product/193435614X?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=193435614X)

Pragmatic Programmers came out with a book called 'A ThoughtWorks Anthology' which has an essay called 'Refactoring Ant Build Files'. It shows how you can apply common refactoring principals to Ant build files to remove the cruft that builds up over time.

After another break I moved over to another room to attend Scott Davis' presentation on DSLs (Domain Specific Languages) in Groovy. An example of a domain is Facebook, which we would consider a part of the social networking domain. Amazon is part of the Internet sales and cloud computing domains.

One of the dangers is attempting to put too much domain and losing the specific nature of the DSL. The joy of DSLs is the ability to build the language tools specific for the job. SQL is an example of a domain specific language as is ANT. SQL provides a strong language for retrieving data. ANT is intended just for building Java code.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS Spring 2009 - Day Three</title> 
  		<link>http://tragicallyleet.com/2009/04/16/nfjs-spring-2009-day-three.html</link> 
  		<comments>http://tragicallyleet.com/2009/04/16/nfjs-spring-2009-day-three.html#comments</comments> 
  		<pubDate>Thu, 16 Apr 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/04/16/nfjs-spring-2009-day-three.html</description> 
  		<content:encoded><![CDATA[ NOTE: I delayed posting these entries to clean up my notes and add some useful links.

<i>GRUMPY NOTE: I lost a bunch of notes so this is based on my faulty memory and some slides.</i>

I got in a little late today after grabbing coffee and headed to [Michael Nygard's](http://michaelnygard.com/) presentation "Architect for Scale". I love the smell of capacity math in the morning.

### Amdahl's Law

$$ T_p = \sigma T_1 + ( 1 - \sigma ) \frac{T_1}{p} $$ 

#### Speedup Ratio

[pmath]S_p=T_1/1+sigma(p-1) [/pmath] 

### Universal Scalability Law

[pmath]C_p=p/1+sigma(p-1)+kappa p(p-1)[/pmath]
where
[pmath]sigma[/pmath] = contention
[pmath]kappa[/pmath] = coherency

Michael mentioned a book, [Guerrilla Capacity Planning](http://www.amazon.com/gp/product/3540261389?ie=UTF8&tag=mylibrary01-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=3540261389) by Neil Gunther. It covers a lot of the mathematics of scalability and capacity planning.

There are only two ways to increase scalability: decrease contention or decrease conherency. Why is "improve performance" not on the list? Increasing performance increases capacity. Scalability is the measure of how added resources impact added capacity. Increasing performance can reduce your need for scalability, but does not benefit scalability. An interesting side note was that increasing performance generally means making the serial portion ([pmath]sigma[/pmath]) a larger portion of the total time. This means that as you spend more time on performance, you actually create a situation where you will reach maximum capacity with fewer processing resources.

### Brewer's Conjecture

You have heard the old quote "Faster, better, cheaper... Pick two"? Well when you are talking about systems architecture you can choose at most two of the following: 

- Consistency
- Availability
- Partition-Tolerance

Lets look at Michael's definitions: 

Consistency:
  There exists a total ordering on all operations, and all nodes in the system agree on that ordering at every point in time.
Availability:
  Every request received by a non-failing node must result in a response
Partition-Tolerance:
  The network may lose arbitrarily many messages from any subset of nodes to any other subset of nodes.

You want your system to be consistent and available? Partitioning is not allowed. How are you going to prevent partitioning? Do you expect servers, switches and network cards to never fail? This is unrealistic.

You want your system to be consistent and partitionable? Consistency can only be guaranteed if the service is unavailable during partitions. Otherwise you end up with 'split-brain'.

You want your system to be available and partitionable? We maintain availability during partitions by allowing different subsets to report different histories. This means that agreement or synchronization protocols are forbidden.

An important note: when you use and rely on ACID compliance of a relational database, you inherently select **Consistency**.

> "If you can't split it, you can't scale it." -- Randy Shoup, eBay

All partitioning strategies assume no cross-cluster dependencies on shared data. Shared writable data requires serialized access which raised [pmath]sigma[/pmath].

The database theory example for ACID compliance of a bank transaction is flawed as soon as User A and User B are with different banks. Instead of 'always consistent' we need to think about 'eventually consistent'.

[![Release It!](https://images-na.ssl-images-amazon.com/images/I/41Nb-knuW-L._SL160_.jpg){: .left}](http://www.amazon.com/gp/product/0978739213?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0978739213)

I decided to hang around for Michael's next talk, 'The 90-Minute Startup'. He talked about Amazon EC2. I lost all my notes on this talk, but seeing the cloud in action was pretty cool.

After lunch we had the expert panel discussion where Ken Sipe, Ted Neward, Matthew McCullough, Brian Sam-Bodden, and Michael Nygard talked about issues like the potential future of software development regulation, the potential impact of the IBM-Sun aquisition, and parallels between software engineering and the medical, legal, and construction.

After the panel I attended Ken Sipe's session on Java Memory, Performance, and Garbage Collection. I learned a bunch about the theory of garbage collection on the JVM. I picked up a few nice tips. To speed up your JVM startup time set your PermSpace and MaxPermSpace to the values based on what you see while your application is running. This way the JVM is not allocating space, finding is insufficent, reallocating over and over as you start up.

Some useful equations from the JVM memory management talk.

[pmath]E=S_n-(S_n/(R_s+2))*2[/pmath]

[pmath]S_s=(S_n-E)/2[/pmath]

where
[pmath]E[/pmath] = Size of Eden
[pmath]S_n[/pmath] = Size of New Space
[pmath]R_s[/pmath] = Survivor Ratio
[pmath]S_s[/pmath] = Size of Survivor Space

jps allows you to see processes either locally or remotely.

jstatd exposes the process information to jps over the network. A java security policy file is needed.

I stuck around for Ken&rsquo;s session as my last of the day, &ldquo;Debugging the Production JVM&rdquo;. After an example of VisualVM he moved into BTrace, a new feature in Java 1.6. It allows you to instrument a running JVM and get events when methods are called, or other activities take place.

All in all I had a great time and learned a whole bunch.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS - Fall 2009 - Day One</title> 
  		<link>http://tragicallyleet.com/2009/09/22/nfjs-fall-2009-day-one.html</link> 
  		<comments>http://tragicallyleet.com/2009/09/22/nfjs-fall-2009-day-one.html#comments</comments> 
  		<pubDate>Tue, 22 Sep 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/09/22/nfjs-fall-2009-day-one.html</description> 
  		<content:encoded><![CDATA[ Its that time again! The No Fluff Just Stuff : Pacific Northwest Software Symposium has returned to the Redmond Marriot.

### Effective Java - Venkat Subramaniam

Unlike many talks, Venkat let us chose the topics. He put up a Jeopardy style board with categories like 'Syntax Sugar', 'Collections' and 'Objects' and let us pick. The content varied wildly, not in its quality (Venkat knows his stuff) but in just how deep into the rabbit hole it would lead you.

As an example, which is better?

{% highlight java %}
string1 + string2
new StringBuffer(string1).append(string2)
{% endhighlight %}

Normally you might think that the simple + would be less efficient, but thanks to syntactic sugar the opposite is true.

In Java 1.4 and above the simple + will use StringBuilder in the background. StringBuilder will preallocate space based on expectations and will not acquire and release locks like StringBuffer will.

There were a lot of code examples and we covered pitfalls and Java strangeness like the above.

### Common Antipatterns - Mark Richards

We started talking about common antipatterns in life as an example.

There are some common causes of anti-patterns:

- haste - aggressive deadlines and budgets drive lower standards of quality
- apathy - general lack of concern about finding the proper solution to a problem
- arrogance - refusal to accept solutions or practices generally known to be effective
- ignorance - failure (intentional or non-intentional) to seek a clear understanding of the problem space
- pride - refusal to leverage existing designs, code and frameworks; builds everything from scratch

**Object Orgy** - insufficiently encapsulated objects result in unrestricted access to their internals.

**Cargo Cult Programming** - using patters, methods and techniques without understanding why.

**Golden Hammer** - using the same tool, product or technique to solve every problem.

With the plethora of languages available on the JVM, we have all kinds of choice. For a comprehensive list of language options, see [http://www.is-research.de/info/vmlanguages/](http://www.is-research.de/info/vmlanguages/)

**Accidental Complexity** - introducing non-essential complexity into a solution.

> essential complexity: we have a hard problem
> 
> accidental complexity: we have made a problem hard
> 
> "developers are drawn to complexity like moths to a flame - often with the same result" - Neal Ford

**Lava Flow** - obsolete technologies and forgotten extensions leave hardened globules of dead code in its wake.

**The Blob** - an all encompassing class or component that knows too much and does too much.

Use a roles and responsibility model. Figure out in just a couple of sentences what the job of a given object is.

**Architecture by Implication** - systems lacking a clear architecture definition.

Don't rely too heavily on past experience; every problem is a little different.

### Groovy Testing - Scott Davis

There are some real benefits to using Groovy for testing. Groovy has the ability to get into the private guts of a Java object.

The concept of a 'private' field is a Java *language* construct, not a Java *platform* construct. This means you can get to private methods and fields.

### Keynote - Venkat Subramaniam

Venkat gave the keynote after dinner; an entertaining talk about the pointy-hairness in all of us, not just bosses.

 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS - Fall 2009 - Day Two</title> 
  		<link>http://tragicallyleet.com/2009/09/23/nfjs-day-two.html</link> 
  		<comments>http://tragicallyleet.com/2009/09/23/nfjs-day-two.html#comments</comments> 
  		<pubDate>Wed, 23 Sep 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/09/23/nfjs-day-two.html</description> 
  		<content:encoded><![CDATA[ ### Dim Sum Grails - Scott Davis

Grails is an open-source web framework written in Groovy. Grails is being used by major players like Wired.com, Taco Bell in Canada, and more. 

If you have ever created a domain (model) object in Grails and noticed the scaffolding lists fields in alphabetical order, there is a simple way past this. When you add your fields to the static constraints closure, Grails will output them in the order provided.

{% highlight groovy %}
class MyObject {
	String firstName
	String lastName
	Integer age
	
	static constraints = {
		lastName()
		firstName()
		age()
	}
}
{% endhighlight %}

Want to add Lucene to your application? Try this.

{% highlight text %}
> grails install-plugin searchable
{% endhighlight %}

All that is left to give yourself a search engine is add searchable=true to your domain classes.

{% highlight groovy %}
class MyObject {
	...
	static searchable = true	
	...
}
{% endhighlight %}

Once you have done that, start your application with grails run-app annd go to http://localhost:8080/app/searchable to see your search page.

### Design Patterns in Java and Groovy - Venkat Subramaniam

I have always had an interest in patterns since I attended Pattern Languages of Programming (PLoP) in 2006. Venkat refered to Java as a post-pattern language; the Gang of Four Design Patterns book came out just before Java, and so patterns are far easier to implement in Java than C++. Likewise we have power and flexibility in Groovy that we do not have in Java that enables pattern implementation.

I found myself in an interesting conversation with Barbee Davis and Ted Neward, so I was late to the next session.

### MOPping up Groovy - Venkat Subramaniam

This session was about meta-programming techniques in Groovy. My favorite part was the end where Venkat wrote a  executable DSL (domain specific language) in Groovy.

At this point I was pretty tired and none of the last set of panels really interested me, so I went home a little early.
 ]]></content:encoded> 
  		</item>
    <item> 
  		<title>NFJS – Fall 2009 – Day Three</title> 
  		<link>http://tragicallyleet.com/2009/09/24/nfjs-fall-2009-day-three.html</link> 
  		<comments>http://tragicallyleet.com/2009/09/24/nfjs-fall-2009-day-three.html#comments</comments> 
  		<pubDate>Thu, 24 Sep 2009 00:00:00 -0800</pubDate> 
  		<dc:creator>Jeffrey Hulten</dc:creator> 
  		<guid isPermaLink="true">http://tragicallyleet.com</guid> 
  		<description>/2009/09/24/nfjs-fall-2009-day-three.html</description> 
  		<content:encoded><![CDATA[ Ah, the final day of No Fluff...

I spent the morning talking with Barbee Davis and Suzie Lewis Ship about topics ranging from science fiction to Agile development. As a result I missed Ken Sipe's Iteration 0 panel.

### 7 Habits of Highly Effective Developers - Ken Sipe

Ken's session is about applying the [The 7 Habits of Highly Effective People](http://www.amazon.com/gp/product/0743269519?ie=UTF8&tag=tragicallyl33-20&linkCode=as2&camp=1789&creative=390957&creativeASIN=0743269519) by Stephen Covey to software developers. 

Covey's seven habits are:
- be proactive
- begin with the end in mind
- put first things first
- seek first to understand, then to be understood
- synergize
- sharpen the saw

Ken referred to a blog post "[Top 5 Attributes of Highly Effective Programmers](http://www.philosophicalgeek.com/2008/01/20/5-attributes-of-highly-effective-programmers/)". The attributes from that post are:

- Humility
- Love of Learning
- Detail Orientedness
- Adaptability
- Passion

He has his own list: 

- focused on a mission with a vision
- best researcher
- best debugger
- god complex when it comes to software development
  - not a lack of humility
  - just optimism to be able to do anything on the computer
- quality focused
- detailed oriented!

### Clojure - Howard Lewis Ship

I have never programmed in Lisp. Considering the other panels in the same time slot I figured I would do something about that and increase my knowledge with the Clojure session.

Clojure is a partial Lisp clone on the JVM with support for software transactional memory to keep your concurrent processes running smoothly.

### Hacking Your Brain for Fun and Profit - Nathaniel Schutta

This was the last panel I attended for the weekend, and a lot of fun. I enjoy thinking about and discussing learning techniques and such.

The only topic I will touch on here is the need for sleep. According to the [research](http://www.spokane.wsu.edu/ResearchOutreach/Sleep/documents/2003SLP-VanDongen-etal.pdf) Nate referenced, if you consistently get six hours of sleep when you need eight it is like missing two nights of sleep. Staying up one night results in a 30% drop in cognitive function...

So go take a nap. A 26 minute nap gives a 34% boost to performance.
 ]]></content:encoded> 
  		</item>
